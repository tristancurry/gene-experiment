<html>
<style type = 'text/css'>
#viewport {
	display: flex;
	flex-direction: column;
	width: fit-content;
	border: 2px solid black;
	box-shadow: inset 0px 0px 5px rgba(0,0,0,1);
}

#being {
	background: rgb(2,0,36);
	background: linear-gradient(315deg, rgba(2,0,36,1) 0%, rgba(16,16,89,1) 35%, rgba(63,19,92,1) 100%);
	stroke-width: 3px;
}



#mod1 {
	display: block;
}
</style>



<body>
<div id='viewport'>

<svg id="being" width="400" height="400" xmlns="http://www.w3.org/2000/svg">

 
  <circle cx="0" cy="200" r="8" fill="red"/>
  <circle cx="400" cy="200" r="8" fill="red"/>
  <circle cx="0" cy="400" r="8" fill="red"/>
  <circle cx="400" cy="400" r="8" fill="red"/>

  <circle id="mod1circle" cx="20" cy="20" r="5" fill="cyan"/>
  <circle id="mod2circle" cx="380" cy="20" r="5" fill="yellow"/>


</svg>
<input id="mod1x" type="range" min="0" max="400" />
<input id="mod1y" type="range" min="0" max="400" />
<input id="mod2x" type="range" min="0" max="400" />
<input id="mod2y" type="range" min="0" max="400" />
</div>


<script type='text/javascript'>

	const defaultLockTime = 120;
    let locked = true;
	let lockTime = defaultLockTime;

	let circSpeed = 2;
	let circMaxFactor = 5;
	let circAcc = 0.005;
	let circRepulse = -200;

	let mod1x = document.getElementById('mod1x');
	let mod1y = document.getElementById('mod1y');
	let mod1circle = document.getElementById('mod1circle');
	let mod1circleAngle = 2*Math.PI*Math.random();
	let mod1circleSpeed = 0;
	let mod1circleMass = 1;
	let r1 = mod1circle.getAttribute('r');

	let mod2x = document.getElementById('mod2x');
	let mod2y = document.getElementById('mod2y');
	let mod2circle = document.getElementById('mod2circle');
	let mod2circleAngle = 2*Math.PI*Math.random();
	let mod2circleSpeed = 0;
	let mod2circleMass = 1;
	let r2 = mod2circle.getAttribute('r');


	let pathy = {
		name: 'pathy',
		start: {x: 0, y: 200},
		end: {x: 400, y: 200},
		//need to divide into segments, each with own control points
		//a mutation can determine whether to use C, Q, S or T for each seg
		cpoints: [
			{x: 20, y: 20},
			{x: 380, y: 20}
		],
		markup: '',

		assemblePath: function () {
			let d = `M ${this.start.x} ${this.start.y} C`;
			for (let i = 0, l = this.cpoints.length; i < l; i++) {
				d += `${this.cpoints[i].x} ${this.cpoints[i].y}, `;
			}
			d += `400 200 L 400 400 L 0 400 Z`;
			return d;
		},

		update: function () {
			this.element.setAttribute('d', this.assemblePath());
		},

		createMarkup: function () {
			pathy.markup = `<path id="${this.name}" d="${this.assemblePath()}" stroke="white" fill="black" />`;
		},

		render: function (target) {
			target.insertAdjacentHTML('afterbegin', this.markup);
		}
	}

	pathy.createMarkup();
	pathy.render(being);
	pathy.element = document.getElementById(pathy.name);


	mod1x.value = 20;
	mod1x.addEventListener('input', () => {
		pathy.cpoints[0].x = parseFloat(mod1x.value);
		mod1circle.setAttribute('cx', `${mod1x.value}`);
		pathy.update();
	});

	mod1y.value = 20;
	mod1y.addEventListener('input', () => {
		pathy.cpoints[0].y = parseFloat(mod1y.value);
		mod1circle.setAttribute('cy', `${mod1y.value}`);
		pathy.update();

	});

	mod2x.value = 380;
	mod2x.addEventListener('input', () => {
		pathy.cpoints[1].x = parseFloat(mod2x.value);
		mod2circle.setAttribute('cx', `${mod2x.value}`);
		pathy.update();
	});

	mod2y.value = 20;
	mod2y.addEventListener('input', () => {
		pathy.cpoints[1].y = parseFloat(mod2y.value);
		mod2circle.setAttribute('cy', `${mod2y.value}`);
		pathy.update();
	});

	function changePathic() {
		pathic.setAttribute('d', `M 0 200 C ${mod1x.value} ${mod1y.value}, ${mod2x.value} ${mod2y.value}, 400 200 L 400 400 L 0 400 Z`);
	}

	




			


			 

</script>
</body>
</html>