<html>
<style type = 'text/css'>
#viewport {
	display: flex;
	flex-direction: column;
	width: fit-content;
	border: 2px solid black;
	box-shadow: inset 0px 0px 5px rgba(0,0,0,1);
}

#being {
	background: rgb(2,0,36);
	background: linear-gradient(315deg, rgba(2,0,36,1) 0%, rgba(16,16,89,1) 35%, rgba(63,19,92,1) 100%);
	stroke-width: 3px;
}



#mod1 {
	display: block;
}
</style>



<body>
<div id='viewport'>

<svg id="being" width="400" height="400" xmlns="http://www.w3.org/2000/svg">

 
  <circle cx="0" cy="200" r="8" fill="red"/>
  <circle cx="400" cy="200" r="8" fill="red"/>
  <circle cx="0" cy="400" r="8" fill="red"/>
  <circle cx="400" cy="400" r="8" fill="red"/>

  <circle id="mod1circle" cx="20" cy="20" r="5" fill="cyan"/>
  <circle id="mod2circle" cx="180" cy="20" r="5" fill="yellow"/>


</svg>
<input id="mod1x" type="range" min="0" max="400" />
<input id="mod1y" type="range" min="0" max="400" />
<input id="mod2x" type="range" min="0" max="400" />
<input id="mod2y" type="range" min="0" max="400" />
</div>


<script type='text/javascript'>


	function Segment (type = 'C', end = {x:0, y:0}) {
		this.cpoints = [];
		this.end = {x: end.x, y: end.y};

		
		if(this.seg_cpoints[type]) {
			for (let i = 0, l = this.seg_cpoints[type]; i < l; i++) {
				this.cpoints.push({x:0, y:0});
			}
			this.type = type;
		} else {
			this.type = 'C';
		}
	}

	Segment.prototype.seg_cpoints = {
		C: 2,
		S: 1,
		Q: 1,
		T: 0,
		L: 0,
	}

	function Pathicle (options = {}) {
		var options = options;
		this.name = options.name || 'Bob';
		this.start = options.start || {x: 0, y: 200};
		this.end = options.end || {x:400, y: 200};
		this.segments = [];
		this.markup = '';


		// pathy.segments[0].end = pathy.end;
		this.createMarkup();
		this.render(being);
		this.element = document.getElementById(this.name);
	}

	Pathicle.prototype.assemblePath = function () {
		let d = `M ${this.start.x} ${this.start.y} `;
		for (let i = 0, l = this.segments.length; i < l; i++) {
			let thisSegment = this.segments[i];
			if (i == l - 1) {thisSegment.end = this.end;}
			d += `${thisSegment.type} `;
			console.log(thisSegment);
			console.log(thisSegment.seg_cpoints[thisSegment.type]);
			if(thisSegment.seg_cpoints[thisSegment.type] > 0) {
				for (let j = 0, m = thisSegment.seg_cpoints[thisSegment.type]; j < m; j++) {
					d += `${thisSegment.cpoints[j].x} ${thisSegment.cpoints[j].y}, `;
				}
			}

			d += `${thisSegment.end.x} ${thisSegment.end.y} `; 	
		}
		d += `L 400 400 L 0 400 Z`;
		return d;
	}

	Pathicle.prototype.createMarkup = function () {
		this.markup = `<path id="${this.name}" d="${this.assemblePath()}" stroke="white" fill="black" />`;
	}

	Pathicle.prototype.update = function () {
		this.element.setAttribute('d', this.assemblePath());
	}

	Pathicle.prototype.render = function (target) {
			target.insertAdjacentHTML('afterbegin', this.markup);
	}



	let pathy = new Pathicle({name: 'pathy'});


	pathy.segments.push(new Segment());

	pathy.segments[0].cpoints = [
		{x: 20, y: 20},
		{x: 180, y: 20}
	];
	pathy.segments[0].end = {x:200, y:200};

	let seg2 = new Segment('L');
	seg2.cpoints = [
		{x: 380, y: 200}
	];

	pathy.segments.push(seg2);
	pathy.update();



	mod1x.value = 20;
	mod1x.addEventListener('input', () => {
		pathy.segments[0].cpoints[0].x = parseFloat(mod1x.value);
		mod1circle.setAttribute('cx', `${mod1x.value}`);
		pathy.update();
	});

	mod1y.value = 20;
	mod1y.addEventListener('input', () => {
		pathy.segments[0].cpoints[0].y = parseFloat(mod1y.value);
		mod1circle.setAttribute('cy', `${mod1y.value}`);
		pathy.update();

	});

	mod2x.value = 200;
	mod2x.addEventListener('input', () => {
		pathy.segments[0].cpoints[1].x = parseFloat(mod2x.value);
		mod2circle.setAttribute('cx', `${mod2x.value}`);
		pathy.update();
	});

	mod2y.value = 20;
	mod2y.addEventListener('input', () => {
		pathy.segments[0].cpoints[1].y = parseFloat(mod2y.value);
		mod2circle.setAttribute('cy', `${mod2y.value}`);
		pathy.update();
	});

pathy.update();
	


//need to encode genes for
//curve type.
//control points (locations)
//curve end point

//the transcription is an ongoing, dynamic process that generates proteins that have consequences for the shape
//proteins are soaked up in producing phenotypic things
//e.g. there's a gene for a C with control points a and b.
//this is transcribed into a protein that produces this effect. (NB there can be transcription errors!)
//there may be multiple transcriptions of the same gene, producing a lot of this protein
//at the same time, there's another protein being generated that produces a different C
//proteins that affect the exact same 'area' are selected from at random. Their effects are averaged.
//the selection continues until all 'slots' are used. The 'slots' are determined by the size of the structure, and genetic factors.
//excess proteins are exchanged between structures, excreted wholesale, or broken down by lysosomal action
//every action here takes energy to perform
//other excess material remains in the structure for the next round of allocations. this can end up preventing absorption into the structure
//or preventing it from producing the mix of proteins required for survival.

			


			 

</script>
</body>
</html>