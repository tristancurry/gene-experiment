<html>
<style type = 'text/css'>
#viewport {
	display: flex;
	flex-direction: column;
	width: fit-content;
	border: 2px solid black;
	box-shadow: inset 0px 0px 5px rgba(0,0,0,1);
}

#being {
	background: rgb(2,0,36);
	background: linear-gradient(315deg, rgba(2,0,36,1) 0%, rgba(16,16,89,1) 35%, rgba(63,19,92,1) 100%);
	stroke-width: 3px;
}



#mod1 {
	display: block;
}
</style>



<body>
<div id='viewport'>

<svg id="being" width="400" height="400" xmlns="http://www.w3.org/2000/svg">

 
  <circle cx="0" cy="200" r="8" fill="red"/>
  <circle cx="400" cy="200" r="8" fill="red"/>
  <circle cx="0" cy="400" r="8" fill="red"/>
  <circle cx="400" cy="400" r="8" fill="red"/>

  <circle id="mod1circle" cx="20" cy="20" r="5" fill="cyan"/>
  <circle id="mod2circle" cx="180" cy="20" r="5" fill="yellow"/>


</svg>
<input id="mod1x" type="range" min="-800" max="800" />
<input id="mod1y" type="range" min="-800" max="800" />
<input id="mod2x" type="range" min="-800" max="800" />
<input id="mod2y" type="range" min="-800" max="800" />
</div>


<script type='text/javascript'>


	//for this test, 'proteinA' will affect the location of the control points for a cubic bezier
	let addParam = function (param, inc) {
		//aside from effects on other proteins, the protein may also have
		//a list of direct effects on the appearance of a structure
		//in this case, it's to increase the x-coordinate of the first control point
		//the effect needs to be applied as a component of a 'force' against the existing value
		//every modifiable parameter needs a temporary buffer for building this force calculation - create at 'gene expression' step
		//TODO: find a way to subdivide an existing bezier curve to allow for growth


				return param + inc;


	}

	function Segment (type = 'C', end = {x:0, y:0}) {
		this.cpoints = [];
		this.end = {x: end.x, y: end.y};
		this.exprs = {};
		for (let i = 0, l = 2; i < l; i++) {
			this.cpoints.push({x:0, y:0});
			this.exprs[`cpoint${i}x`] = {val: this.cpoints[i].x, ref: ['cpoints', i, 'x']};
			this.exprs[`cpoint${i}y`] = {val: this.cpoints[i].y, ref: ['cpoints', i, 'y']};
		}
		if(this.seg_cpoints.hasOwnProperty(type)) {
			this.type = type;
		} else {
			this.type = 'C';
		}
	}

	Segment.prototype.seg_cpoints = {
		C: 2,
		S: 1,
		Q: 1,
		T: 0,
		L: 0,
	}
	


	Segment.prototype.effectLookup = {
		A: [
				{
					effect:addParam, 
					expr: 'cpoint1x',
					args: [10]
				},

				{
					effect: addParam,
					expr: 'cpoint0x',
					args: [-10]
				}
			],

		B: [
				{
					effect:addParam, 
					expr: 'cpoint1y',
					args: [-5]
				}
		],
	}

	Segment.prototype.express = function () {
		for (let e in this.exprs) {
			let expr = this.exprs[e];
			if (expr) {
				if(expr.ref) {
					this[expr.ref[0]][expr.ref[1]][expr.ref[2]] = expr.val;
				}
			}
		}
	}



	function Pathicle (options = {}) {
		var options = options;
		this.name = options.name || 'Bob';
		this.start = options.start || {x: 0, y: 200};
		this.end = options.end || {x:400, y: 200};
		this.segments = [];
		this.markup = '';


		// pathy.segments[0].end = pathy.end;
		this.createMarkup();
		this.render(being);
		this.element = document.getElementById(this.name);
	}

	Pathicle.prototype.assemblePath = function () {
		let d = `M ${this.start.x} ${this.start.y} `;
		for (let i = 0, l = this.segments.length; i < l; i++) {
			let thisSegment = this.segments[i];
			if (i == l - 1) {thisSegment.end = this.end;}
			d += `${thisSegment.type} `;

			if(thisSegment.seg_cpoints[thisSegment.type] > 0) {
				for (let j = 0, m = thisSegment.seg_cpoints[thisSegment.type]; j < m; j++) {
					d += `${thisSegment.cpoints[j].x} ${thisSegment.cpoints[j].y}, `;
				}
			}

			d += `${thisSegment.end.x} ${thisSegment.end.y} `; 	
		}
		d += `L 400 400 L 0 400 Z`;
		return d;
	}

	Pathicle.prototype.createMarkup = function () {
		this.markup = `<path id="${this.name}" d="${this.assemblePath()}" stroke="white" fill="black" />`;
	}

	Pathicle.prototype.update = function () {
		this.element.setAttribute('d', this.assemblePath());
	}

	Pathicle.prototype.render = function (target) {
			target.insertAdjacentHTML('afterbegin', this.markup);
	}





	let pathy = new Pathicle({name: 'pathy'});


	pathy.segments.push(new Segment('C'));

	pathy.segments[0].cpoints = [
		{x: 20, y: 20},
		{x: 180, y: 20}
	];
	pathy.segments[0].end = {x:200, y:200};

	let seg2 = new Segment('S');
	seg2.cpoints[0] = {x: 380, y: 200};

	pathy.segments.push(seg2);
	pathy.update();



	mod1x.value = 20;
	mod1x.addEventListener('input', () => {
		pathy.segments[0].cpoints[0].x = parseFloat(mod1x.value);
		mod1circle.setAttribute('cx', `${mod1x.value}`);
		pathy.update();
	});

	mod1y.value = 20;
	mod1y.addEventListener('input', () => {
		pathy.segments[0].cpoints[0].y = parseFloat(mod1y.value);
		mod1circle.setAttribute('cy', `${mod1y.value}`);
		pathy.update();

	});

	mod2x.value = 200;
	mod2x.addEventListener('input', () => {
		pathy.segments[0].cpoints[1].x = parseFloat(mod2x.value);
		mod2circle.setAttribute('cx', `${mod2x.value}`);
		pathy.update();
	});

	mod2y.value = 20;
	mod2y.addEventListener('input', () => {
		pathy.segments[0].cpoints[1].y = parseFloat(mod2y.value);
		mod2circle.setAttribute('cy', `${mod2y.value}`);
		pathy.update();
	});

	
	
//this step involves only the proteins that are left after binding, excretion, lysing etc
//i.e. the ones that 'get to' have direct, visible effects

let doProteinEffects = function (target) {
	//for each genetic property, create a temporary buffer.
	//for now though...work on control points
	//active proteins will be location-specific (arriving there by transport/diffusion/production)
	//work through each protein in the list. Currently there are three of these.
	let activeProteins = [{name: 'A', units: 50}, {name: 'B', units: 25}, {name: 'C', units: 3}];
	activeProteins.forEach(protein => {
		console.log(`Now deploying protein '${protein.name}'!`);
		if(!target.effectLookup[protein.name]) {
			//do nothing
			console.log(`Protein '${protein.name}' has no prescribed effect.`)
		} else {
			console.log(`Protein '${protein.name}' has prescribed effects.`)
			if(!target.effectLookup[protein.name]) {
				//no effect. Protein remains in structure until removed.
			} else {
				let proteinEffects = target.effectLookup[protein.name];
				proteinEffects.forEach(thisEffect => {
					let thisExpr = target.exprs[thisEffect.expr];
					let accumulator = thisExpr.val;
					let units = protein.units;
					while(units > 0) {
						accumulator = thisEffect.effect(accumulator, thisEffect.args[0]);
						units -= 1;
					}
					target.exprs[thisEffect.expr].val = accumulator;
				});
				protein.units = 0;
		
			}
	
		}
	});
	target.express();
}



//working title. Start with one segment and see how the gene decoding goes.



doProteinEffects(pathy.segments[0]);
pathy.update();
let eventy = new Event('input');
mod1x.value = pathy.segments[0].cpoints[0].x;
mod1y.value = pathy.segments[0].cpoints[0].y;
mod2x.value = pathy.segments[0].cpoints[1].x;
mod1y.value = pathy.segments[0].cpoints[1].y;
mod1x.dispatchEvent(eventy);
mod1y.dispatchEvent(eventy);
mod2x.dispatchEvent(eventy);
mod2y.dispatchEvent(eventy);

//need to encode genes for
//curve type.
//control points (locations)
//curve end point
//ribosomal efficiency (energy, speed of production, error rate)
//lysosomal efficiency
//there is a limited (but very large) number of 'receptor' functions describing an effect.
//these receptors can be inhibited by the actions of certain proteins or even environmental effects.
//the receptors have a certain number of slots, too. This is subject to genetic factors too...
//start with a small, but fixed, number of receptors that have fixed slots and sensitivities
//this will be in the form of a lookup table.

//proteins look like
// CBNQPCQNBFAXNBAAANMBABB
// CB    NQPC      QNB      FAXN        BAAB										NM 						BABB
// type  receptor  strngth  receptor   	can attach to active gene sites ba and ab	spacer (one of several)	can directly bind proteins BA and BB
//bound proteins (and the binding proteins) are removed from functional processes. Not all proteins bind others.

//receptor looks like
//NQPC     ABV		bAqT     NFR          CrBr     mfL
//receptor slots    effect1  strength     effect2  strength

//individual effects drawn from expansive library of effects.
//these effects change depending on the context (e.g. tissue type)?
//so each gene needs a number of 'switches'...effectively those active gene sites.
//a protein can attach to a given switch and either enhance the gene action to a degree, or repress it
//another protein can bind to these proteins and remove them. So we have to keep track of which proteins are bound to the genes?

//create a 'protein' object, and bind to a 'gene' object.
//do we want to notionally create 'gene' objects that are then compiled into a genome for exposure to the user? I wanted this to be pretty obscure.

//active gene attachment sites allow protein mediated expression of genes. 
//receptor on gene looks like
//NQPC
//receptor 
//these can either be promoting or inhibiting receptors. This allows proteins to bind directly to these sites.
//there are also less specific protein binding sites (ab, aa, etc) that allow a multitude of different proteins to bind.

//those receptor codes could be complementary to the protein's receptor code.


//the transcription is an ongoing, dynamic process that generates proteins that have consequences for the shape
//proteins are soaked up in producing phenotypic things
//e.g. there's a gene for a C with control points a and b.
//this is transcribed into a protein that produces this effect. (NB there can be transcription errors!)
//there may be multiple transcriptions of the same gene, producing a lot of this protein
//at the same time, there's another protein being generated that produces a different C
//proteins that affect the exact same 'area' are selected from at random. Their effects are averaged.
//the selection continues until all 'slots' are used. The 'slots' are determined by the size of the structure, and genetic factors.
//excess proteins are exchanged between structures, excreted wholesale, or broken down by lysosomal action
//every action here takes energy to perform
//other excess material remains in the structure for the next round of allocations. this can end up preventing absorption into the structure
//or preventing it from producing the mix of proteins required for survival.

			
//each structure has its own number of cells which affects the protein production (more 'trials' in probability-driven transcription system)

			 
//start with assumption that each unit has ribosomes and lysosomes - later code for these in the genetic sequence.

//5 stages of growth? Timing regulated by gene activity. Different sets of genes activate at different times...

</script>
</body>
</html>