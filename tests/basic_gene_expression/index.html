<html>
<style type = 'text/css'>
#viewport {
	display: flex;
	flex-direction: column;
	width: fit-content;
	border: 2px solid black;
	box-shadow: inset 0px 0px 5px rgba(0,0,0,1);
}

#being {
	background: rgb(2,0,36);
	background: linear-gradient(315deg, rgba(2,0,36,1) 0%, rgba(16,16,89,1) 35%, rgba(63,19,92,1) 100%);
	stroke-width: 3px;
}



#mod1 {
	display: block;
}
</style>



<body>
<div id='viewport'>

<svg id="being" width="400" height="400" xmlns="http://www.w3.org/2000/svg">

 
  <circle cx="0" cy="200" r="8" fill="red"/>
  <circle cx="400" cy="200" r="8" fill="red"/>
  <circle cx="0" cy="400" r="8" fill="red"/>
  <circle cx="400" cy="400" r="8" fill="red"/>

  <circle id="mod1circle" cx="20" cy="20" r="5" fill="cyan"/>
  <circle id="mod2circle" cx="180" cy="20" r="5" fill="yellow"/>
	<circle id="splitcircle" cx="-100" cy="-100" r="5" fill="green"/>


</svg>
<input id="mod1x" type="range" min="-800" max="800" />
<input id="mod1y" type="range" min="-800" max="800" />
<input id="mod2x" type="range" min="-800" max="800" />
<input id="mod2y" type="range" min="-800" max="800" />
</div>


<script type='text/javascript'>
	let splitcircle = document.getElementById('splitcircle');

	//for this test, 'proteinA' will affect the location of the control points for a cubic bezier
	let addParam = function (param, inc) {
		//aside from effects on other proteins, the protein may also have
		//a list of direct effects on the appearance of a structure
		//in this case, it's to increase the x-coordinate of the first control point
		//the effect needs to be applied as a component of a 'force' against the existing value
		//every modifiable parameter needs a temporary buffer for building this force calculation - create at 'gene expression' step
		//TODO: find a way to subdivide an existing bezier curve to allow for growth


				return param + inc;


	}



	let subdivideSegment = function (segment, pieces = 2) {

		//need start/end and control points of this segment
		//that's going to depend on segment type
		//also - consider manipulating these in the horizontal frame of each segment (rather than the canvas frame)
		//that way, any distortions can be replicated across structures pointing in different directions.
		let s = segment;
		let z = 1;
		if(pieces !== 0 && typeof pieces === 'number') {
			z = 1/pieces;
		}

		let coeffs = {
			quadratic: [z**2, z*(z-1), (z-1)**2],
			cubic: [z**3, (z**2)*(z-1), z*((z-1)**2), (z-1)**3],
		}

		let P = {
			x: [],
			y: []
		}

		//before this, need some way of generating the right control points if we are dealing
		//with one of the 'continuation' types (i.e. S or T)
		//also need to alter the behaviour if type is linear or quadratic!


		//generate a pair of Q's that will store the control points for both new Beziers

		let Q_0 = {
			x: [],
			y: []
		};

		let Q_1 = {
			x: [],
			y: []
		}


		if(segment.type == 'C' || segment.type == 'S') {
			//let it rain. each Q.x and Q.y has length of 4 (4 cps)
			//do something different for type S segments
			for(let i in P) {
				P[i] = [s.start[i], s.cpoints[0][i], s.cpoints[1][i], s.end[i]];
			}
			console.log(P);


			for (let i in Q_0) {
				let thisP = P[i];
				Q_0[i] = [
					thisP[0], 
					z*thisP[1] - (z-1)*thisP[0],
					coeffs.quadratic[0]*thisP[2] - 2*coeffs.quadratic[1]*thisP[1] + coeffs.quadratic[2]*thisP[0],
					coeffs.cubic[0]*thisP[3] - 3*coeffs.cubic[1]*thisP[2] + 3*coeffs.cubic[2]*thisP[1] - coeffs.cubic[3]*thisP[0]
				];
				Q_1[i] = [
					coeffs.cubic[0]*thisP[3] - 3*coeffs.cubic[1]*thisP[2] + 3*coeffs.cubic[2]*thisP[1] - coeffs.cubic[3]*thisP[0],
					coeffs.quadratic[0]*thisP[3] - 2*coeffs.quadratic[1]*thisP[2] + coeffs.quadratic[2]*thisP[1],
					z*thisP[3] - (z-1)*thisP[2],
					thisP[3]
				]
			}

		} else if (segment.type == 'Q' || segment.type == 'T') {
			//each Q.x and Q.y has length of 3 (3cps)
			//Load start, end and cp into P and do the thing.
			for(let i in P) {
				P[i] = [s.start[i], s.cpoints[0][i], s.end[i]];
			}
			console.log(P);

		} else if (segment.type == 'L') {
			//Q.x and Q.y have length of 2. Just the start and end points.
			//use linear interpolation to find the splitting point and simply break the two pieces.
			//Load start and end points into P. then do the linear interp.
			for(let i in P) {
				P[i] = [s.start[i], s.end[i]];
			}
			console.log(P);
		
		} else {
			//if it's not any of the allowable types, refuse to divide it
			console.log('segment could not be divided (was not a recognised type, e.g. C, S, Q, T or L)' );
			return segment;
		}



		console.log(Q_0);
		console.log(Q_1);

		//second piece gets recursively split unless it's no longer necessary. In that case, make segments and return both pieces.


		
		let primrose = new Segment('C', {x:Q_0.x[0], y:Q_0.y[0]}, {x:Q_0.x[3], y:Q_0.y[3]});
		primrose.cpoints[0] = {x:Q_0.x[1], y:Q_0.y[1]};
		primrose.cpoints[1] = {x:Q_0.x[2], y:Q_0.y[2]};
		
		let lavender = [];
		let peony = new Segment('C', {x:Q_1.x[0], y:Q_1.y[0]}, {x:Q_1.x[3], y:Q_1.y[3]});
		if(pieces > 2) {
			lavender = subdivideSegment(peony, pieces - 1);
		}
		console.log(lavender);
		if(lavender.length > 0) {
			return [primrose, lavender[0], lavender[1]];
		} else {
			return [primrose, peony];
		}

	}

	function Segment (type = 'C', start = {x:0, y: 0}, end = {x:0, y:0}) {
		this.cpoints = [];
		this.start= {x: start.x, y: start.y};
		this.end = {x: end.x, y: end.y};
		this.exprs = {};
		for (let i = 0, l = 2; i < l; i++) {
			this.cpoints.push({x:0, y:0});
			this.exprs[`cpoint${i}x`] = {val: this.cpoints[i].x, ref: ['cpoints', i, 'x']};
			this.exprs[`cpoint${i}y`] = {val: this.cpoints[i].y, ref: ['cpoints', i, 'y']};
		}
		if(this.seg_cpoints.hasOwnProperty(type)) {
			this.type = type;
		} else {
			this.type = 'C';
		}
	}

	Segment.prototype.seg_cpoints = {
		C: 2,
		S: 1,
		Q: 1,
		T: 0,
		L: 0,
	}
	


	Segment.prototype.effectLookup = {
		A: [
				{
					effect:addParam, 
					expr: 'cpoint1x',
					args: [10]
				},

				{
					effect: addParam,
					expr: 'cpoint0x',
					args: [-10]
				}
			],

		B: [
				{
					effect:addParam, 
					expr: 'cpoint1y',
					args: [-5]
				}
		],
	}

	Segment.prototype.express = function () {
		for (let e in this.exprs) {
			let expr = this.exprs[e];
			if (expr) {
				if(expr.ref) {
					this[expr.ref[0]][expr.ref[1]][expr.ref[2]] = expr.val;
				}
			}
		}
	}



	function Pathicle (options = {}) {
		var options = options;
		this.name = options.name || 'Bob';
		this.start = options.start || {x: 0, y: 200};
		this.end = options.end || {x:400, y: 200};
		this.segments = [];
		this.markup = '';


		// pathy.segments[0].end = pathy.end;
		this.createMarkup();
		this.render(being);
		this.element = document.getElementById(this.name);
	}

	Pathicle.prototype.assemblePath = function () {
		let d = `M ${this.start.x} ${this.start.y} `;
		for (let i = 0, l = this.segments.length; i < l; i++) {
			let thisSegment = this.segments[i];
			if (i == l - 1) {thisSegment.end = this.end;}
			d += `${thisSegment.type} `;

			if(thisSegment.seg_cpoints[thisSegment.type] > 0) {
				for (let j = 0, m = thisSegment.seg_cpoints[thisSegment.type]; j < m; j++) {
					d += `${thisSegment.cpoints[j].x} ${thisSegment.cpoints[j].y}, `;
				}
			}

			d += `${thisSegment.end.x} ${thisSegment.end.y} `; 	
		}
		d += `L 400 400 L 0 400 Z`;
		return d;
	}

	Pathicle.prototype.createMarkup = function () {
		this.markup = `<path id="${this.name}" d="${this.assemblePath()}" stroke="white" fill="black" />`;
	}

	Pathicle.prototype.alignSegments = function () {
		//go through list of segments. Match start of next seg with end of previous
		for (let i = 0, l = this.segments.length; i < l; i++) {
			let thisSegment = this.segments[i];
			if (i == 0) {
				thisSegment.start = this.start;
			} else {
				thisSegment.start = this.segments[i - 1].end;
			}
			if (i == l - 1) {
				thisSegment.end = this.end;
			}
		}
	}

	Pathicle.prototype.update = function () {
		this.alignSegments();
		this.element.setAttribute('d', this.assemblePath());
	}

	Pathicle.prototype.render = function (target) {
			target.insertAdjacentHTML('afterbegin', this.markup);
	}

	Pathicle.prototype.subdivideSegment = function (segment, pieces = 2) {
		let subSegs = subdivideSegment(segment, pieces);
		console.log(subSegs);
		let idx = this.segments.indexOf(segment);
		console.log(idx);
		for (let i = subSegs.length - 1; i >= 0; i--) {
			this.segments.splice(idx + 1, 0, subSegs[i]);
		}
		this.segments = this.segments.filter(seg => seg !== segment);
	}





	let pathy = new Pathicle({name: 'pathy'});


	pathy.segments.push(new Segment('C'));

	pathy.segments[0].cpoints = [
		{x: 20, y: 20},
		{x: 180, y: 20}
	];
	pathy.segments[0].end = {x:200, y:200};

	let seg2 = new Segment('S');
	seg2.cpoints[0] = {x: 380, y: 200};
	seg2.cpoints[1] = {x: 380, y: 200};

	pathy.segments.push(seg2);
	pathy.update();



	mod1x.value = 20;
	mod1x.addEventListener('input', () => {
		pathy.segments[0].cpoints[0].x = parseFloat(mod1x.value);
		mod1circle.setAttribute('cx', `${mod1x.value}`);
		pathy.update();
	});

	mod1y.value = 20;
	mod1y.addEventListener('input', () => {
		pathy.segments[0].cpoints[0].y = parseFloat(mod1y.value);
		mod1circle.setAttribute('cy', `${mod1y.value}`);
		pathy.update();

	});

	mod2x.value = 200;
	mod2x.addEventListener('input', () => {
		pathy.segments[0].cpoints[1].x = parseFloat(mod2x.value);
		mod2circle.setAttribute('cx', `${mod2x.value}`);
		pathy.update();
	});

	mod2y.value = 20;
	mod2y.addEventListener('input', () => {
		pathy.segments[0].cpoints[1].y = parseFloat(mod2y.value);
		mod2circle.setAttribute('cy', `${mod2y.value}`);
		pathy.update();
	});

	
	
//this step involves only the proteins that are left after binding, excretion, lysing etc
//i.e. the ones that 'get to' have direct, visible effects

let doProteinEffects = function (target) {
	//for each genetic property, create a temporary buffer.
	//for now though...work on control points
	//active proteins will be location-specific (arriving there by transport/diffusion/production)
	//work through each protein in the list. Currently there are three of these.
	let activeProteins = [{name: 'A', units: 50}, {name: 'B', units: 25}, {name: 'C', units: 3}];
	activeProteins.forEach(protein => {
		console.log(`Now deploying protein '${protein.name}'!`);
		if(!target.effectLookup[protein.name]) {
			//do nothing
			console.log(`Protein '${protein.name}' has no prescribed effect.`)
		} else {
			console.log(`Protein '${protein.name}' has prescribed effects.`)
			if(!target.effectLookup[protein.name]) {
				//no effect. Protein remains in structure until removed.
			} else {
				let proteinEffects = target.effectLookup[protein.name];
				proteinEffects.forEach(thisEffect => {
					let thisExpr = target.exprs[thisEffect.expr];
					let accumulator = thisExpr.val;
					let units = protein.units;
					while(units > 0) {
						accumulator = thisEffect.effect(accumulator, thisEffect.args[0]);
						units -= 1;
					}
					target.exprs[thisEffect.expr].val = accumulator;
				});
				protein.units = 0;
		
			}
	
		}
	});
	target.express();
}



//working title. Start with one segment and see how the gene decoding goes.



doProteinEffects(pathy.segments[0]);
pathy.update();
let eventy = new Event('input');
mod1x.value = pathy.segments[0].cpoints[0].x;
mod1y.value = pathy.segments[0].cpoints[0].y;
mod2x.value = pathy.segments[0].cpoints[1].x;
mod1y.value = pathy.segments[0].cpoints[1].y;
mod1x.dispatchEvent(eventy);
mod1y.dispatchEvent(eventy);
mod2x.dispatchEvent(eventy);
mod2y.dispatchEvent(eventy);

//need to encode genes for
//curve type.
//control points (locations)
//curve end point
//ribosomal efficiency (energy, speed of production, error rate)
//lysosomal efficiency
//there is a limited (but very large) number of 'receptor' functions describing an effect.
//these receptors can be inhibited by the actions of certain proteins or even environmental effects.
//the receptors have a certain number of slots, too. This is subject to genetic factors too...
//start with a small, but fixed, number of receptors that have fixed slots and sensitivities
//this will be in the form of a lookup table.

//proteins look like
// CBNQPCQNBFAXNBAAANMBABB
// CB    NQPC      QNB      FAXN        BAAB										NM 						BABB
// type  receptor  strngth  receptor   	can attach to active gene sites ba and ab	spacer (one of several)	can directly bind proteins BA and BB
//bound proteins (and the binding proteins) are removed from functional processes. Not all proteins bind others.

//receptor looks like
//NQPC     ABV		bAqT     NFR          CrBr     mfL
//receptor slots    effect1  strength     effect2  strength

//individual effects drawn from expansive library of effects.
//these effects change depending on the context (e.g. tissue type)?
//so each gene needs a number of 'switches'...effectively those active gene sites.
//a protein can attach to a given switch and either enhance the gene action to a degree, or repress it
//another protein can bind to these proteins and remove them. So we have to keep track of which proteins are bound to the genes?

//create a 'protein' object, and bind to a 'gene' object.
//do we want to notionally create 'gene' objects that are then compiled into a genome for exposure to the user? I wanted this to be pretty obscure.

//active gene attachment sites allow protein mediated expression of genes. 
//receptor on gene looks like
//NQPC
//receptor 
//these can either be promoting or inhibiting receptors. This allows proteins to bind directly to these sites.
//there are also less specific protein binding sites (ab, aa, etc) that allow a multitude of different proteins to bind.

//those receptor codes could be complementary to the protein's receptor code.


//the transcription is an ongoing, dynamic process that generates proteins that have consequences for the shape
//proteins are soaked up in producing phenotypic things
//e.g. there's a gene for a C with control points a and b.
//this is transcribed into a protein that produces this effect. (NB there can be transcription errors!)
//there may be multiple transcriptions of the same gene, producing a lot of this protein
//at the same time, there's another protein being generated that produces a different C
//proteins that affect the exact same 'area' are selected from at random. Their effects are averaged.
//the selection continues until all 'slots' are used. The 'slots' are determined by the size of the structure, and genetic factors.
//excess proteins are exchanged between structures, excreted wholesale, or broken down by lysosomal action
//every action here takes energy to perform
//other excess material remains in the structure for the next round of allocations. this can end up preventing absorption into the structure
//or preventing it from producing the mix of proteins required for survival.

			
//each structure has its own number of cells which affects the protein production (more 'trials' in probability-driven transcription system)

			 
//start with assumption that each unit has ribosomes and lysosomes - later code for these in the genetic sequence.

//5 stages of growth? Timing regulated by gene activity. Different sets of genes activate at different times...

</script>
</body>
</html>